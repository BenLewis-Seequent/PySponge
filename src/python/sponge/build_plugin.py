
import os
import sys
import shutil
import subprocess
import pkg_resources
import zipfile
import urllib2

import re

# url of the ivy artifact
ivy_url = "http://www.us.apache.org/dist//ant/ivy/2.4.0/apache-ivy-2.4.0-bin-with-deps.zip"

jython_jar_pattern = re.compile(".*jython-standalone-[0-9.b]+\.jar")


class Injection(object):
    """
    Model of a java field that is injected in by guice
    """
    def __init__(self, clazz, field):
        """
        Creates an injection

        :param clazz: fully qualified name of the type of the field
        :param field: field name
        """
        self.clazz = clazz
        self.field = field
        self.annotations = {}

    def add_annotation(self, name, **args):
        """
        Add an annotation to the field

        :param name: fully qualified name of the annotation
        :param args: key-value pairs for the arguments of the annotation
        """
        self.annotations[name] = args

game_injection = Injection("org.spongepowered.api.Game", "game")
logger_injection = Injection("org.slf4j.Logger", "logger")
event_manager_injection = Injection("org.spongepowered.api.service.event.EventManager", "event_manager")
# TODO add the other injectors
default_injections = [game_injection, logger_injection, event_manager_injection]


class PluginResult(object):
    def __init__(self, jar):
        self.jar = jar

    def install(self, game_directory):
        shutil.copy(self.jar, os.path.join(game_directory, 'mods'))


def plugin(plugin_id,
           name,
           version,
           sponge_api_version="2.1-SNAPSHOT",
           main="__main__",
           injections=default_injections,
           build_dir ='build',
           task=None,
           bundle_jython=True):
    """
    Builds a skeleton of a pysponge plugin.

    The output is a jar file within the build directory and if that jar
    is placed in the 'mods' folder of a Sponge profile/server it loads
    the plugin.

    The expected usage is that there is a 'setup.py' at the root of the
    source directory of the plugin. And in that file there is a call to this
    method. So to run the setup, navigate to the root of the source directory
    and run 'python setup.py'.

    There are two tasks this method accepts()passed by either the task parameter
    or command line argument):
        'dev' - Builds the jar so that it looks for the python files of the
                plugin in the current working directory when invoking this
                method.

                So any changes made to the python files are reflected
                immediately upon restart of sponge without the need to rerun
                this method.

        'jar' - Builds the jar so that the python files of the plugin are
                bundled within the jar. This is used to distribute the
                plugins.

    :param plugin_id:          id of the plugin
    :param name:               human readable name of the plugin
    :param version:            version of the plugin
    :param sponge_api_version: Sponge API version to compile against
    :param main:               name of the plugins main module
    :param injections:         list of injections to add to the generated plugin
                               class
    :param build_dir:          directory in which this method uses for its
                               output and temporary files
    :param task:               task to perform
    :param bundle_jython:      whether to bundle standalone jython jar inside
                               the output jar. If false jython needs to be on
                               the classpath when running the plugin.
    :rtype: PluginResult
    :return: object representing the result of the task
    """
    if task is None:
        if len(sys.argv) <= 1:
            raise RuntimeError("No task specified. Either pass it as an method or command line argument")
        task = sys.argv[1]
    if task not in ["dev", "jar"]:
        raise RuntimeError("Unknown task "+task)

    # create build directory if empty
    if not os.path.exists(build_dir):
        os.mkdir(build_dir)

    # gen interface
    interface_dir = os.path.join("interface", "sponge")
    if not os.path.exists(interface_dir):
        os.makedirs(interface_dir)
    with open(os.path.join(interface_dir, "inject.pyi"), 'w') as f:
        f.write(_gen_interface(injections))

    # setup ivy distribution
    ivy = _setup_ivy(build_dir)
    # ivy config files
    ivy_file_name = os.path.join(build_dir, "ivy.xml")
    ivy_file = file(ivy_file_name, "w")
    ivy_file.write(_gen_ivy_file(sponge_api_version))
    ivy_file.close()
    ivy_settings_file = pkg_resources.resource_filename(
        "sponge", "ivysettings.xml")

    # file that will hold the classpath to use for compilation
    # this will be generated by ivy
    classpath_filename = os.path.join(build_dir, "classpath.txt")
    # run ivy
    subprocess.call(["java", "-jar", ivy,
                     "-ivy", ivy_file_name,
                     "-settings", ivy_settings_file,
                     "-cachepath", classpath_filename])

    # read in the classpath
    classpath_file = open(classpath_filename)
    classpath = classpath_file.read()
    classpath_file.close()

    # create source directory
    src_dir = os.path.join(build_dir, "src")
    package_dir = os.path.join(src_dir, *plugin_id.split('.'))
    if not os.path.exists(package_dir):
        os.makedirs(package_dir)

    # create java plugin file
    plugin_class = _gen_source(plugin_id, name, version, main, task == 'jar', injections)
    plugin_class_filename = os.path.join(package_dir, "PyPlugin.java")
    plugin_class_file = file(plugin_class_filename, 'w')
    plugin_class_file.write(plugin_class)
    plugin_class_file.close()

    classes_dir = os.path.join(build_dir, 'classes')
    if not os.path.exists(classes_dir):
        os.mkdir(classes_dir)

    # compile the java plugin class
    subprocess.call(["javac",
                     "-cp", classpath,
                     "-d", classes_dir,
                     plugin_class_filename])

    # create the jar
    jar_filename = os.path.join(build_dir, '{}-{}.jar'.format(plugin_id, version))
    jar = zipfile.ZipFile(jar_filename, mode="w")

    def add_jar_entry(arg, dirname, fnames):
        base, out, func = arg
        for fname in fnames:
            fname = os.path.join(dirname, fname)
            if os.path.isfile(fname) and func(fname):
                rel = os.path.relpath(fname, base)
                if out is None:
                    path = rel
                else:
                    path = os.path.join(out, rel)
                jar.write(fname, path)

    os.path.walk(classes_dir,
                 add_jar_entry,
                 (classes_dir, None, lambda f: f.endswith(".class")))
    # copy binding python source files
    py_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    build_file = os.path.join(py_root, "sponge", "build_plugin.py")
    os.path.walk(py_root,
                 add_jar_entry,
                 (py_root, "Lib", lambda f: f.endswith(".py") and f != build_file))

    if task == "jar":
        # add python files under Lib directory in the the jar
        os.path.walk(".",
                     add_jar_entry,
                     (".", "Lib", lambda f: f.endswith(".py")))

    if bundle_jython:
        for item in classpath.split(':'):
            if jython_jar_pattern.match(item) is not None:
                _copy_jython(jar, item)

    jar.close()
    return PluginResult(jar_filename)


def _setup_ivy(build_dir):
    base_ivy_path = os.path.join(build_dir, 'ivy')
    if not os.path.exists(base_ivy_path):
        os.mkdir(base_ivy_path)
    ivy_path = os.path.join(base_ivy_path, 'apache-ivy-2.4.0', 'ivy-2.4.0.jar')
    if not os.path.exists(ivy_path):
        # if ivy cannot be found download it
        # following is copied from http://stackoverflow.com/a/22776/2609357
        ivy_zip_name = os.path.join(base_ivy_path, 'apache-ivy-2.4.0-bin-with-deps.zip')
        u = urllib2.urlopen(ivy_url)
        f = open(ivy_zip_name, 'wb')
        meta = u.info()
        file_size = int(meta.getheaders("Content-Length")[0])
        print "Downloading: %s Bytes: %s" % (ivy_zip_name, file_size)

        file_size_dl = 0
        block_sz = 8192
        while True:
            buffer = u.read(block_sz)
            if not buffer:
                break

            file_size_dl += len(buffer)
            f.write(buffer)
            status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            status = status + chr(8)*(len(status)+1)
            print status,

        f.close()
        # unpack the downloaded zip file
        ivy_zip = zipfile.ZipFile(ivy_zip_name)
        ivy_zip.extractall(base_ivy_path)
        ivy_zip.close()
    return ivy_path


def _gen_ivy_file(api_version):
    return """<ivy-module version="2.0">
  <info organisation="com.skinny121"
        module="PySponge"/>
  <dependencies>
      <dependency org="org.spongepowered" name="spongeapi" rev="{}"/>
      <dependency org="org.python" name="jython-standalone" rev="2.7.1b2"/>
  </dependencies>
</ivy-module>""".format(api_version)


def _gen_source(plugin_id, name, version, main, bundled, injections):
    if main.endswith(".py"):
        main = main[:-3]
    py_exec = 'import {} as m; m.start(this)'.format(main)
    if not bundled:
        py_exec = \
            'import sys; sys.path.append(\\"{}\\");'.format(os.getcwd()) + \
            py_exec
    header = """// file is auto generated by build_plugin.py
package {};
import org.spongepowered.api.event.Listener;
import org.spongepowered.api.event.game.state.GameConstructionEvent;
import org.spongepowered.api.plugin.Plugin;

import com.google.inject.Inject;

import org.python.util.PythonInterpreter;
import org.python.core.PyStringMap;
import org.python.core.Py;
import org.python.core.PySystemState;

@Plugin(id = "{}", name = "{}", version = "{}")
public class PyPlugin {{

""".format(plugin_id, plugin_id, name, version)

    fields = "".join(map(_gen_injection, injections))

    return header + fields + """    @Listener
    public void init(GameConstructionEvent e) {{
        PySystemState.initialize();
        PyStringMap locals = new PyStringMap();
        locals.__setitem__("this", Py.java2py(this));

        PythonInterpreter interpreter = new PythonInterpreter(locals);
        interpreter.exec("{}");
    }}
}}
""".format(py_exec)


def _gen_injection(injection):
    def _gen_annotation(annotation, args):
        if len(args):
            return "@{}({}){}    ".format(
                annotation,
                ", ".join(["{} = {}".format(k, v) for k, v in args.iteritems()]),
                os.linesep)
        else:
            return "@{}".format(annotation)

    annotations = ''.join(
        [_gen_annotation(k, v) for k, v in injection.annotations.iteritems()])
    return """    @Inject
    {}public {} {};

""".format(annotations, injection.clazz, injection.field)


def _gen_interface(injections):
    def _gen_import(injection):
        return "import {}".format(injection.clazz)

    def _gen_declarations(injection):
        return "{} = ...  # type: {}".format(injection.field,
                                             injection.clazz)

    return "{}{}{}{}".format(os.linesep.join(map(_gen_import, injections)),
                             os.linesep*2,
                             os.linesep.join(map(_gen_declarations, injections)),
                             os.linesep)


def _copy_jython(jar, jython_path):
    jython_jar = zipfile.ZipFile(jython_path)
    for entry in jython_jar.filelist:
        entry_data = jython_jar.read(entry)
        jar.writestr(entry, entry_data)
